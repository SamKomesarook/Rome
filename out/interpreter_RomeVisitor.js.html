<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: interpreter/RomeVisitor.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: interpreter/RomeVisitor.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { RomeVisitor } from "../lang/RomeVisitor";
import Utility from "./InterpreterUtility";

/**
 * Custome Visitor inherit from RomeVisitor which is generated by anltr4
 */
class RVisitor extends RomeVisitor {
  constructor(
    memArr,
    updateContentType,
    moveMem,
    writeContent,
    freeMem,
    sendMemAnimation,
    readMemAnimation,
    printAnimation
  ) {
    super();
    this.memArr = memArr;
    this.updateContentType = updateContentType;
    this.moveMem = moveMem;
    this.writeContent = writeContent;
    this.freeMem = freeMem;
    this.sendMemAnimation = sendMemAnimation;
    this.readMemAnimation = readMemAnimation;
    this.printAnimation = printAnimation;
    this.netImported = false;
    this.ioImported = false;
  }

  visitChildren(ctx) {
    if (!ctx) {
      return;
    }
    if (ctx.children) {
      return ctx.children.map(child => {
        if (child.children &amp;&amp; child.children.length !== 0) {
          return child.accept(this);
        } else {
          return child.getText();
        }
      });
    }
  }

  /**
   * start of the visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitR(ctx) {
    console.log("Visit R!");
    return this.visitChildren(ctx);
  }

  /**
   * loop visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitLoop(ctx) {
    console.log("Visit Loop");
    var utility = new Utility();
    var command = utility.getCommand(ctx);
    var arg = utility.getCommandArg("loop".length + 1, command);
    var num = utility.loopMemCommand(arg, this.memArr);
    for (var i = 0; i &lt; num; i++) {
      this.visitChildren(ctx);
    }
    return;
  }

  /**
   * set visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitSet(ctx) {
    console.log("Visit Set!");
    var utility = new Utility();
    var command = utility.getCommand(ctx);
    var arg = utility.getCommandArg("set".length + 1, command);
    var selectedMem = utility.getSelectedMemId(this.memArr);
    var tempMem = this.memArr[selectedMem];
    var tempMemObj = utility.createMemObj(
      tempMem.props.id,
      tempMem.type.name,
      tempMem.props.selected,
      tempMem.props.content,
      arg
    );
    // only allow set content type when memory is empty
    if (tempMemObj.getContent() !== "") {
      alert("Memory isn't empty!");
    } else {
      this.updateContentType(selectedMem, tempMemObj);
    }
    return this.visitChildren(ctx);
  }

  /**
   * move visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitMove(ctx) {
    console.log("Visit Move!");
    var utility = new Utility();
    var command = utility.getCommand(ctx);
    var arg = utility.getCommandArg("move".length + 1, command);
    var selectedMem = utility.getSelectedMemId(this.memArr);
    var validMove = utility.checkMemRange(selectedMem, arg);
    if (validMove) {
      var tempOldMem = this.memArr[selectedMem];
      var tempNewMem =
        arg === "next"
          ? this.memArr[selectedMem + 1]
          : this.memArr[selectedMem - 1];
      // set current selected memory selected status to false
      var tempOldMemObj = utility.createMemObj(
        tempOldMem.props.id,
        tempOldMem.type.name,
        false,
        tempOldMem.props.content,
        tempOldMem.props.contentType
      );
      // set the target memory selected status to true
      var tempNewMemObj = utility.createMemObj(
        tempNewMem.props.id,
        tempNewMem.type.name,
        true,
        tempNewMem.props.content,
        tempNewMem.props.contentType
      );
      this.moveMem(tempOldMemObj, tempNewMemObj);
    }
    return this.visitChildren(ctx);
  }

  /**
   * write visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitWrite(ctx) {
    console.log("Visit write!");
    var utility = new Utility();
    var command = utility.getCommand(ctx);
    var arg = utility.getCommandArg("write".length + 1, command);
    var selectedMem = utility.getSelectedMemId(this.memArr);
    var tempMem = this.memArr[selectedMem];
    var newMemObj = utility.createMemObj(
      tempMem.props.id,
      tempMem.type.name,
      tempMem.props.selected,
      arg,
      tempMem.props.contentType
    );
    // check content type and memory availability
    var matchedType = utility.contentTypeMatch(newMemObj.contentType, arg);
    var contentAvail = utility.memAvailability(tempMem.props.content);
    if (!matchedType) {
      alert("Wrong type!");
    } else if (!contentAvail) {
      alert("Memory is not available!");
    } else {
      this.writeContent(newMemObj);
    }
    return this.visitChildren(ctx);
  }

  /**
   * Kread visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitKread(ctx) {
    console.log("Visit Read!");
    var utility = new Utility();
    var selectedMem = utility.getSelectedMemId(this.memArr);
    var tempMem = this.memArr[selectedMem];
    var typeAllow = tempMem.props.contentType;
    var userInput = "";
    // force user input something and whitespace only is not allowed
    while (userInput === "" || userInput === null || userInput.match(/^\s+$/)) {
      userInput = prompt("User Input, Please enter a " + typeAllow + " type");
    }
    var newMemObj = utility.createMemObj(
      tempMem.props.id,
      tempMem.type.name,
      tempMem.props.selected,
      userInput,
      tempMem.props.contentType
    );
    // check content type and memory availability
    var matchedType = utility.contentTypeMatch(
      newMemObj.contentType,
      userInput
    );
    var contentAvail = utility.memAvailability(tempMem.props.content);
    if (!matchedType) {
      alert("Wrong type!");
    } else if (!contentAvail) {
      alert("Memory is not available!");
    } else {
      this.writeContent(newMemObj);
    }
    return this.visitChildren(ctx);
  }

  /**
   * free visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitFree(ctx) {
    console.log("Visit free!");
    var utility = new Utility();
    var selectedMem = utility.getSelectedMemId(this.memArr);
    var tempMem = this.memArr[selectedMem];
    var tempMemObj = utility.createMemObj(
      tempMem.props.id,
      tempMem.type.name,
      tempMem.props.selected,
      "",
      tempMem.props.contentType
    );
    this.freeMem(tempMemObj);
    return this.visitChildren(ctx);
  }

  /**
   * memory visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitMem(ctx) {
    console.log("Visit Mem!");
    var utility = new Utility();
    var command = utility.getCommand(ctx);
    var arg = utility.getCommandArg("memory".length + 1, command);
    // if arg is a number, get memory block using the number
    if (!isNaN(arg)) {
      var tempMem = this.memArr[arg];
      if (tempMem.props.contentType === "letters") {
        // alert("Memory Content is not a number");
        console.log("Memory content is not a number");
      } else {
        // console.log("Memory content: ", tempMem.props.content);
        return tempMem.props.content;
      }
    } else {
      // recursively memory interpreter
      return this.visitChildren(ctx);
    }
  }

  /**
   * if visitor
   * conditional regex: ((is|not)\ (less|greater|equal)\ (([0-9])|memory\([0-9]+\)))+
   * @param {Object} ctx context generated by antlr4
   */
  visitIf(ctx) {
    console.log("Visit if!");
    var utility = new Utility();
    var command = utility.getCommand(ctx);
    var arg = utility.getCommandArg("if".length + 1, command);
    // get current selected memory
    var selectedMem = this.memArr[utility.getSelectedMemId(this.memArr)];
    var condState = utility.checkCond(arg, selectedMem);
    if (condState) {
      return this.visitChildren(ctx);
    }
  }

  /**
   * n_write visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitSnet(ctx) {
    console.log("Visit Send Net!");
    var utility = new Utility();
    var imported = utility.checkImp(this.netImported);
    const netMemId = 14;
    if (imported) {
      var command = utility.getCommand(ctx);
      var arg = utility.getCommandArg("n_write".length + 1, command);
      var netMem = this.memArr[netMemId];
      var netMemObj = utility.createMemObj(
        netMemId,
        netMem.type.name,
        netMem.props.selected,
        arg,
        netMem.props.contentType
      );
      netMemObj.setAnimated(true);
      this.sendMemAnimation(netMemObj);
    }
    return this.visitChildren(ctx);
  }

  /**
   * n_read visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitRnet(ctx) {
    console.log("Visit Receive Net!");
    var utility = new Utility();
    var imported = utility.checkImp(this.netImported);
    const netMemId = 14;
    if (imported) {
      var receivedContent = utility.stringGenerator();
      var netMem = this.memArr[netMemId];
      var netMemObj = utility.createMemObj(
        netMemId,
        netMem.type.name,
        netMem.props.selected,
        receivedContent,
        netMem.props.contentType
      );
      netMemObj.setAnimated(true);
      this.readMemAnimation(netMemObj);
    }
    return this.visitChildren(ctx);
  }

  /**
   * import network visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitNet(ctx) {
    this.netImported = true;
    return this.visitChildren(ctx);
  }

  /**
   * import io visitor
   * @param {Object} ctx context generated by antlr4
   */
  visitIo(ctx) {
    this.ioImported = true;
    return this.visitChildren(ctx);
  }

  /**
   * print to output area, s_write visitor
   * @param {Object} ctx context generate by antlr4
   */
  visitSwrite(ctx) {
    console.log("Visit SWrite!");
    var utility = new Utility();
    var command = utility.getCommand(ctx);
    var arg = utility.getCommandArg("s_write".length + 1, command);
    arg = utility.swriteMemCommand(command, this.memArr);
    this.printAnimation(arg);
  }
}

// export default RomeVisitor;
export default RVisitor;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ErrorReporter.html">ErrorReporter</a></li><li><a href="Interpreter.html">Interpreter</a></li><li><a href="MemoryBlock.html">MemoryBlock</a></li><li><a href="RVisitor.html">RVisitor</a></li><li><a href="Utility.html">Utility</a></li></ul><h3>Global</h3><ul><li><a href="global.html#constructMem">constructMem</a></li><li><a href="global.html#mapMemObjToSymbol">mapMemObjToSymbol</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Oct 10 2019 15:03:18 GMT+1100 (Australian Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
